# PostgreSQL

## PostgreSQL이 무엇인가?

PostgreSQL은 객체 관계형 데이터베이스 관리 시스템(ORDBMS)이다. 이것은 미국 캘리포니아에 있는 버클리 대학 컴퓨터 과학부에서 개발한 POSTGRES, Version4.2를 기반으로 개발되었다.

PostgreSQL은 원래의 버클리 소스를 기반으로 확장된 오픈 소스이다. 이것은 표준 SQL 기능을 대부분 지원하며, 다음과 같은 진보된 많은 기능도 함께 지원한다.

- 복합 쿼리
- 참조키
- 트리거
- 업데이트 가능한 뷰
- 트랜잭션
- 다중 버전 병행 제어

  또한, PostgreSQL에서는 다양한 방법으로 기능을 확장 할 수 있다. 예로, 다음과 같은 것들을 사용자가 직접 새로 만들 수 있다.

- 자료형
- 함수
- 연산자
- 집계 함수
- 인덱스 방법
- 프로시져 언어

그리고, PostgreSQL의 라이센스는 개인적이든, 상업적이든, 교육용이든 어떠한 목적으로도 누구가나, 소스를 수정하고, 재배포 할 수 있다.

## PostgreSQL 설치

대부분의 시스템에는 이미 PostgreSQL패키지가 설치되어있는 경우가 많다. OS의 배포판에 기본으로 내장되고, 특별히 제외시키지 않는다면, 기본적으로 설치되어있기 때문이다. 이런 경우라면, OS배포판 설치문서나 안내문서를 참조하면 PostgreSQL 패키지가 어디에 설치되어있고, 어떻게 사용한는지 알 수 있다.

## 기본 구조

데이터 베이스 전문용어로, PostgreSQL은 클라이언트/서버 모델을 사용하고 있다. 하나의 PostgreSQL세션(작업)은 다음과 같은 프로세스들 (프로그램들)의 상호 작동으로 구성된다.

- 서버 프로세스, 이것은 데이터베이스 파일을 관리하고, 클라이언트 응용 프로그램들이 서버에 연결을 요청할 때, 이 요청들을 처리(수락하거나 거부하는 일)하고, 클라이언트들이 데이터베이스를 사용할 수 있도록 기반 작업들을 준비한다. 이 프로세스의 이름은 postgres이다.
- 클라이언트 프로세스, 이것은 데이터베이스를 사용하려는 사용자 측 응용 프로그램을 말한다. 클라이언트 응용 프로그램은 자연적으로 매우 다양한 형태를 띄고 있다. 어떤 것은 텍스트 기반의 프로그램이기도하고, 어떤것은 그래픽응용 프로그램이기도하고, 어떤 것은 웹서버를 통해서 웹페이지로 보여지기도 한다. 몇 클라이언트 프로그램들은 이미 PostgreSQL 패키지 안에 포함되어서 배포되기도 한다. 이것들은 대부분 사용자들이 직접 개발한 것들이다.

클라이언트/서버 환경의 프로그램들은 대부분이 그렇듯이, PostgreSQL에서도 클라이언트와 서버가 서로 다른 호스트일 수 있다. 이런 경우에는 서로가느이 통신이 TCP/IP 네트워크 기반에서 이루워진다. 클라이언트와 서버가 서로 틀릴 경우에는 클라이언트에서 접근하고자 하는 데이터베이스 파일에 대해서 직접적으로 접근 할 수 없음을 의미한다. 즉, 클라이언트에서 접근 할 수 있는 파일은 그 클라이언트가 실행되고 있는 호스트의 파일이지 서버가 가동중인 호스트의 파일이 아님을 알고 있어야한다.

PostgreSQL서버는 사용자의 다중 접속을 위해서 각 접속에 대해서 새로운 프로세스를 할당한다.(전문용어로 "forks"를 이용한 하위 프로세스 생성이라고도 한다.) 이 방법으로 클라이언트와 새로 만들어진 서버 프로세스간의 작업이 있을 때, 서버의 상위 프로세스 격인 postgres프로세스의 간섭 없이 작업이 이루워짐을 의미한다. 종합하면, postgres프로세스는 서버 호스트에서 항상 실행되고 있으면서, 클라이언트의 접속 요청을 처리해서 새로운 하위 서버 프로세스를 만드는 역할을 한다. 물론 이 모든 작업들은 사용자가 관심을 가지고 살펴보지 않는 이상 서버 차원에서 자동으로 이루워지는 부분이다.

## 데이터 베이스 만들기

각각의 사용자 단위나, 프로젝트 단위로 데이터베이스를 분리해서 작업하는 것이 일반적이기에, 하나의 PostgreSQL 서버는 많은 데이터베이스를 관리 할 수 있다.
어쩌면, 이미 시스템 관리자가 일반 사용자들을 위해서 그들이 사용할 수 있는 데이터베이스를 미리 만들어 두었을 수도 있다. 이런 경우라면, 시스템 관리자가 일반사용자들에게 그 사실을 알려서 사용할 수 있는 데이터베이스 이름을 알려주어야한다.
데이터 베이스 이름은 아무거나 해도된다. PostgreSQL에서는 만들수 있는 데이터베이스 개수 제한이 없다. 하지만 데이터베이스 이름은 첫글자가 영문 알파벳이어야하면 길이는 최대 63바이트까지이다. 데이터베이스 이름으로 가장 편하게 사용할 수 있는 이름은 그 데이터베이스를 만드는 사용자의 이름과 같은 것이다. 왜냐하면 많은 프로그램들이 이 사용자와 같은 이름의 데이터베이스 이름을 그 사용자의 기본 데이터베이스로 가정하기 때문이다.이런식으로 사용자의 이름과 같은 데이터베이스를 만드려면, 아래와 같은 명령을 이용하면 된다.

```code
createdb
```

만든 데이터를 더 이상 사용할 일이 없으면, 데이터베이스를 삭제 할 수 있다. 예를 들어서 mydb 데이터베이스를 만든 사람이 그 데이터베이스를 삭제하려면, 다음과 같은 명령을 이용한다.

```code
dropdb mydb
```

dropdb명령은 그 인자가 없어도 기본으로 삭제할 데이터베이스를 사용자 이름과 같은 데이터베이스를 삭제하지는 않는다. 반드시 삭제할 데이터베이스 이름을 지정해 주어야한다. 이 작업은 해당 데이터베이스와 관련된 모든 파일들을 물리적으로 완전히 삭제하는 것이다. 그러기에 실행 취소를 할 수 없다.이 작업을 할때는 신중히 해야한다.

PostgreSQL서버의 사용자와 시스템 사용자는 엄격히 다르다. 구체적으로 말하자면, 데이터베이스를 만들거나 사용할 수 있는 사용자가 꼭 시스템 사용자로 존재해야하는 것도 아니며, 특정 시스템 사용자가 반드시 PostgreSQL서버의 사용자로 존재해야할 이유도 없다. 단지 PostgreSQL 프로그램들은 해당 데이터베이스를 사용하기 위한 사용자를 지정할 때, 기본적으로 현재 사용중인 시스템 사용자의 이름을 이용한다. 만일 사용자가 없다거나, 해당 사용자의 권한이 부당한 오류 메시지를 만난다면, 그것은 데이터베이스의 사용자에 대한 이야기이다.

## 데이터베이스 사용하기

- psql 이라는 명령어로 PostgreSQL대화형 터미널 프로그램을 실행하기. 이것은 대화형으로 SQL명령을 편집/실행할 수 있다.
- pgAdmin와 같은 그래픽 툴을 이용하거나 ODBC나 JDBC를 이용한 다른 툴들로 데이터베이스를 만들거나 사용할 수 있다.
- 직접응용프로그램을 만들어서 사용하기. PostgreSQL에서는 이런 응용프로그램을 만들 수 있는 다양한 프로그램 언어를 지원한다.

```code
psql mydb
```

데이터 베이스 이름이 빠지면 기본적으로 현재 시스템 사용자 이름과동일한 이름의 데이터베이스에 접속을 시도한다.

서버를 실행한 시스템 사용자 이름과 데이터베이스 사용자이름이 같은 경우 대부분 아래와 같이 보인다.

```code
mydb=#
```

psql프로그램에는 SQL명령 말고도 내부적으로 사용 할 수 있는 명령들이 있다. 이 명령들을 psql 내장 명령어라고 한다. 이 명령들은 역슬래쉬 문자로 시작한다. 예를 들어서 PostgreSQL의 SQL구문을 살펴보자

```code
mydb=> \h
```

psql을 마치려면:

```code
mydb=> \q
```

이 명령이 실행되면, psql프로그램은 종료되고 다시 시스템 쉘 명령 프롬프트가 나타난다.

## SQL언어

psql 프로그램을 실행할 때 -s옵션을 사용하면 SQL명령어들을 하나씩 확인하면서 실행할 수 있다.
PostgreSQL은 관계형 데이터베이스 관리시스템이다. 이 말은 관계들로 구성된 자료를 관리하기위한 시스템이라는 뜻이다. (RDBMS)
이 관꼐라는 용어는 원래 수학용어였는데, 이것이 RDBMS에서는 테이블 사이의 수학적 관계를 설명하는데 이용되었고, 결국 관계형 데이터베이스라는 용어로 사용되었다. 자료를 테이블로 저장하는 방식은 오늘날 너무도 당연한 것으로 인식되고있다. 하지만 이것은 단지, 데이터베이스를 구현하는 여러가지 방법 가운데 하나일 뿐이다. 유닉스 계열 운영체제에서 사용되는 파일과 디렉터리 개념은 계층형 데이터베이스를 구현하는 한 예이다. 또한 최근에는 객체지향 개념을 이용해서 데이터베이스를 구현한다. 각각의 테이블은 로우라고 불리는 것들의 집합이다. 테이블을 구성하는 그 각각의 로우는 특정 자료 형태로 표현되는 각각의 칼럼들의 집합이다. 이 칼럼들의 순서가 각각의 로우에 일정하게 정해져있지만, SQL에서는 테이블의 칼럼을 다룰 때 그 순서가 뒤섞여도 전혀 상관 없다는 사실을 기억해 두어야한다. 이 점이 관계형 db의 중요한 개념이다.
테이블들은 db안에 있고, 이db들의 모음을 하나의 PostgreSQL 서버가 관리한다. 이 하나의 서버가 관리하는 데이터베이스 집합 단위를 클러스터라고한다.

## 새 테이블 만들기

새 테이블은 아래와 같이 테이블의 이름과 그 테이블을 구성하는 각 컬럼과 그 컬럼의 자료형을 지정해서 만든다.

```sql
CREATE TABLE weather (
    city            varchar(80),
    temp_lo         int,           -- low temperature
    temp_hi         int,           -- high temperature
    prcp            real,          -- precipitation
    date            date
);
```

psql안에서는 하나의 sql명령이 여러줄로 나뉘어져 있어도 되고, 한줄로 모두 표현되어도 상관없다. 하지만 하나의 명령은 반드시 하나의 세미콜론으로 끝난다.
sql문장을 작성할 때 공백문자(스페이스,탭, 줄바꿈문자)등은 자유롭게 사용할 수 있다. 즉 굳이 꼭 위와 같이 입력하지 않아도된다. 한줄로 길게 써도 된다. 단지 주의할 것은 "--"문자는 주석을 표현한 것인데 이것이 있으면 그다음부터 줄 끝까지 무시된다. SQL문법에서 예약어(keyword,명령이름, 구문 중간에 나오는 on,default,not null같은 것들)와 식별자(identifier,테이블이름, 칼럼이름 같은 것들)의 대소문자를 구별하지 않느낟. 단지, 식별자가 큰따옴표로 둘러 쌓여지면, 그 식별자는 입력한 그대로의 대소문자를 유지한다.
varchar(80)은 최대길이가 80글자인(byte가아니라 글자이다.)문자열을 저장할 수 있음을 나타내고, int는 정수형 숫자 real은 소숫점을 이용하는 숫자, date는 날짜형을 나타낸다. 칼럼 이름 date가 자료형 date와 같을 수 있다.
PostgreSQL에서는 사용자 정의 자료형을 만들수 있다. 따라서 표준 SQL과의 호환성을 유지하기 위해서 특별히 문법적으로 예약어 기능을 해야하는 것들을 제외한 자료형 이름은 문법적인 예약어가 아니다.

테이블을 삭제하거나 똑같은 이르므이 테이블을 다른 구조로 만드려면 다음과 같은 명령을 사용한다.

```sql
DROP TABLE 테이블이름:
```

## 테이블에 자료 입력하기

```sql
INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');
```

각 칼럼의 실제 자료들은 그 테이블을 만들 때 지정한 자료형과 완벽하게 일치해야한다. 특히 숫자가 아닌 자료일 경우는 위 예제처럼 작은 따옴표로 둘러싼다. 날짜형(date)자료를 입력해야 할 경우는 그 값이 정확하게 날짜 표현이어야한다.
point 자료형은 다음과 같이 하나의 쌍으로 입력되어야한다.

```sql
INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');
```

한편 각 칼럼의 입력 순서를 사용자가 다음과 같이 칼럼명을 미리 원하는 순서대로 지정하고 그 순서에 맞추어 입력할 수도있다.

```sql
INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');
```

이때는 굳이 테이블을 만들 때의 그 칼럼 순서와 같아야할 이유도 없으며, 특정 칼럼을 생략후 입력할 수도 있다.

데이터를 입력하는 또 다른 하나의 방법으로 COPY명령을 사용하는 방법이 있는데, 이것은 대용량 데이터를 빠르게 입력할 때 사용된다. 이 명령은 데이터베이스 백업/복구를 위해서 PostgreSQL전용으로 특별히 만들어진 명령이다. 그래서 자료를 한꺼번에 입력할 떄 아주 유용하다.

```sql
COPY weather FROM '/home/user/weather.txt';
```

이때 지정한 파일은 서버가 가동중인 호스트에 있어야 한다. 접속한 서버가 원격 호스트 경우라면 윗 파일을 원격 호스트에서 찾을 것이다.

## 테이블 자료 조회하기

입력한 자료를 찾아보려면, 테이블에 질의를 해야한다. 이것을 데이터베이스 용어로 쿼리라고한다. 이런 자료조회를 할때 사용할 구문은 SELECT이다. 이 구문은 크게 세 부분으로 구성된다.

1. 원하는 자료의 컬럼을 저장
2. 칼럼들이 있는 테이블들 -from절이라고하고 그다음은 원하는 부분을 지정하는 조건절 -where절이라고 한다.
3. where절이 생략되면 지정한 테이블의 모든 자료를 보여준다.

```sql
SELECT *FROM weather;
```

쿼리 문장은 WHERE절을 이용해서 검색 결과의 조건을 지정할 수 있다. WHERE절에 사용할 조건은 논리조건들의 집합으로 구성된다. 일반적으로 논리조건은 불리언 연산자를 이용해서, WHERE절 전체의 조건을 구성한다.

```sql
SELECT * FROM weather
    WHERE city = 'San Francisco' AND prcp > 0.0;
```

정렬 조건 추가가능

```sql
SELECT * FROM weather
    ORDER BY city;
```

중복제거

```sql
SELECT DISTINCT city
    FROM weather;

```

## table join

```sql
SELECT *
    FROM weather, cities
    WHERE city = name;
```

칼럼이름이 여러 테이블에 똑같이 있다면, 서버는 어떤 테이블에서 그 칼럼을 참조해야 하는지 몰라 오류를 낼 때가 있다. 그래서, 일반적으로 join구문을 작성할때 다음과 같이 칼럼 이름 앞에 테이블 이름을 함꼐지정해서 사용한다. 이것을 qualify(지정자)라고한다.

```sql
SELECT weather.city, weather.temp_lo, weather.temp_hi,
       weather.prcp, weather.date, cities.location
    FROM weather, cities
    WHERE cities.name = weather.city;
```

## 집계함수

다른 대부분의 데이터베이스와 마찬가지로 PostgreSQL에서도 집계함수를 사용할 수 있다. 집계함수란 입력이 여러개의 로우이고, 출력이 하나인 결과인 것을 말한다. 테이블의 전체 로우수를 구하는 count, 평균 ,총합,최댓값,최솟값등등이 이런 함수이다.

```sql
SELECT max(temp_lo) FROM weather;
```

여기서 이 최고 기온의 해당 도시가 무엇인지 알기위해 다음과 같이 생각할 수 있다.

```sql
SELECT city FROM weather WHERE temp_lo = max(temp_lo);    -- 잘못된 구문
```

윗 쿼리는 오류를낸다. 왜냐하면, WHERE 절 다음에는 집계함수를 사용할수 없기 때문이다.(이렇게 되는 이유는 윗예를 들어서 max함수 자체가 select를 하지 않으면 나올 수 없는 값이기 때문이다.) 이런 문제는 다음과 같은 서브쿼리로 풀어야 원하는 결과를 낸다.

```sql
SELECT city FROM weather
    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
```

하나의 쿼리에서 서브쿼리가 있으면, 서버는 서브쿼리를 처리하고 , 그 결과를 서브쿼리가 있는 자리에 대치시키고 다시 쿼리를 한다.
집계함수는 일반적으로 GROUP BY절과 함께 사용하면 보다 다양하고 유용한 결과를 볼 수 있다.

```sql
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city;
```

위 결과 가운데, 또 집계된 자료에 대해서 어떤 조건이 주어질때 HAVING구문 사용

```sql
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city
    HAVING max(temp_lo) < 40;
```

집계 함수를 사용할 때에는 WHERE절과 HAVING절의 관꼐를 반드시 숙지하고 있어야한다. WHERE절은 조회할 집계되지 않은 자료에대한 조건이고, HAVING절은 집계된 자료에 대한 조건이다. 그래서WHERE절의 조건으로 HAVING절이 사용될 수 없다.

## 자료 갱신

이미 입력되어 있는 자료를 수정하려면 UPDATE명령을 사용한다.

```sql
UPDATE weather
    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
    WHERE date > '1994-11-28';
```

## 자료 삭제

테이블에서 필요없는 자료를 삭제하려면 DELETE명령을 사용한다.

```sql
DELETE FROM weather WHERE city = 'Hayward';
```

아래와 같은 구문을 실행할 때에는 항상 조심해야한다.

```sql
DELETE FROM tablename;
```

윗 쿼리는 삭제 작업에서 삭제대상을 지정하지 않았기 때문에 해당 테이블의 전체자료가 삭제 대상이 된다. 처리결과는 해당 테이블에는 아무런 자료도 없게된다. 이때, 그 지워야할 자료가 많다면 시간이 오래걸릴 것이고, 그동안 서버는 클라이언트에게 아무런 응답도 보내지 않는다.
